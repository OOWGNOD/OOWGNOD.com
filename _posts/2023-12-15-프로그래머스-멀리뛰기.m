[##_Image|kage@AU5Vi/btsBfgZ669w/tKDIyDUGq0L9os4uM7xbXK/img.png|CDM|1.3|{"originWidth":512,"originHeight":512,"style":"alignCenter","filename":"javascript_icon_153511.png"}_##]

> 문제 설명  
> 효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는  
> (1칸, 1칸, 1칸, 1칸)  
> (1칸, 2칸, 1칸)  
> (1칸, 1칸, 2칸)  
> (2칸, 1칸, 1칸)  
> (2칸, 2칸)  
> 의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.  
>   
> 제한 사항  
> n은 1 이상, 2000 이하인 정수입니다.  
> 입출력 예

| n | result |
| --- | --- |
| 4  | 5 |
| 3  | 3 |

>   
> 입출력 예 설명  
> 입출력 예 #1  
> 위에서 설명한 내용과 같습니다.  
>   
> 입출력 예 #2  
> (2칸, 1칸)  
> (1칸, 2칸)  
> (1칸, 1칸, 1칸)  
> 총 3가지 방법으로 멀리 뛸 수 있습니다.

처음 풀이 (7번 케이스부터 오답 나옴)

```
function solution(n) {
    let dy = Array.from({length:n+1}, () => 0);
    let k =1234567;
    dy[1] = 1;
    dy[2] = 2;
    for(let i=3; i<=n; i++){
        dy[i]=(dy[i-2]+dy[i-1]);
    }
    return dy[n] % k ;
}
```

이게 왜 틀렸지 생각을 해보았지만 감이 잡히지 않아 질문하기에 올라온 내용들을 살펴보았다.

그 중 나와 같은 케이스의 오답이 있어서 답변 내용을 살펴보니

답변자 : JoChaeWoo

> n 번째 결과가 너무 커서 모든 값을 저장할 수 없어져 오차가 생기는 것입니다.  
> 모듈러 연산(%)은 합성 법칙이 성립하므로 마지막에 나머지 연산으로 처리한 결과와 매 번 나머지 연산한 결과가 같습니다.  
> 값이 너무 커지지 않도록 매 번 나머지 연산을 하면 오차가 발생하지 않을 것입니다.

**합성 법칙**

```
// k =1234567
(a + b) % k == a % k + b % k
fib(n) % k == (fib(n - 1) + fib(n - 2)) % k
(fib(n - 1) + fib(n - 2)) % k == fib(n - 1) % k + fib(n - 2) % k
```

그래서 실제로 n 값을 2000으로 설정한 이후 console.log를 실행해보니

```
let k = 1234567;
console.log((dy[i - 2] + dy[i - 1]) % k);

...

450076
754569
1204645
724647
694725
```

```
console.log(dy[i - 2] + dy[i - 1]);

....

450076
754569
1204645
1959214
1929292
```

값이 실제로 크게 다르다는것을 확인 해볼 수 있었다.

제한 사항

-   n은 1 이상, 2000 이하인 정수입니다.

제한 사항에 대해 깊히 고려하지 않아서 생긴 문제였다. 문제 중 여기에 "1234567를 나눈 나머지를 리턴하는 함수"  이 부분을 지키기 위해 1234567 값은 곱해 주었지만, 값이 반복문을 통해 커짐에 따라 올 문제에 대해서 고려하지 못 하였다. 조건과 제한 사항에 따른 사이드 이펙트에 대해서 다시 한 번 생각해볼 기회였다.
